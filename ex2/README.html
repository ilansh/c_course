<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Ilan Shamir"/><meta name="DCTERMS.issued" content="2011-08-03T16:16:23" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Ilan Shamir"/><meta name="DCTERMS.modified" content="2011-08-14T16:22:56" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><base href="."/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P10 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P11 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P12 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P13 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P14 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P15 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P16 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P17 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P18 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P2 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P3 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P4 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P5 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P6 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P7 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P8 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.P9 { font-size:12pt; font-family:Times New Roman; writing-mode:page; }
	.T15 { font-weight:bold; }
	<!-- ODF styles with no properties representable as CSS -->
	.T1 .T10 .T11 .T12 .T13 .T14 .T16 .T17 .T18 .T19 .T2 .T20 .T21 .T22 .T23 .T24 .T3 .T4 .T5 .T6 .T7 .T8 .T9 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><p class="P1">ilansh</p><p class="P1">302514401</p><p class="P1">Ilan Shamir</p><p class="P1"> </p><p class="P1">Part 1:</p><p class="P1">a. This function inputs the character NULL ('\0' ) at the end of the given string (str) <span class="T23">instead of its last character </span><span class="T24">(assuming the original string ends with NULL)</span>.</p><p class="P1"> </p><p class="P1">b. <span class="T2">The problem with the function is that the method fsacnf </span><span class="T3">reads words sep</span><span class="T6">a</span><span class="T3">rated by spaces (or other white characters), so the function prints </span><span class="T4">each</span><span class="T3"> word </span><span class="T5">scanned from the file</span><span class="T3"> in </span><span class="T4">a new line</span><span class="T3">, </span><span class="T18">and also is not limited to a number of characters in each line.</span></p><p class="P2"><span class="T1">To resolve this problem we can use the method fgets, </span><span class="T7">invoking it with the following syntax:</span></p><p class="P3">fgets(nextLine,MAX_LINE_LENGTH,fln)</p><p class="P7">This call will into the string nextLine from the file pointed by fln, a maximum of MAX_LINE_LENGTH characters, as desired by the function description.</p><p class="P7">In order to avoid double line spaces (since fgets reads the “end line” character as well), we can remove the “\n” from the following printf command.</p><p class="P7"> </p><p class="P8">c. <span class="T8">The code will compile and run properly, but the resulting output would be the string “</span><span class="T9">slabc is an easy course.”</span><span class="T8"> with some junk characters at the end </span><span class="T9">of it</span><span class="T8">.</span></p><p class="P9">The solution to this problem is to exchange the first line from int A[10] to int *A.</p><p class="P9">The problem was caused by the strcat method, <span class="T21">which tries to copy too many characters to the end of</span></p><p class="P14">the array A, causing unexpected behavior, resulting in the junk letters appended at the end of C (which is the same as A, since C and A point to the same location). </p><p class="P8"><span class="T9">The new </span><span class="T10">code </span><span class="T21">doesn't confine A to 10 characters, and allows for more flexible use </span><span class="T22">by the method strcat.</span></p><p class="P15">Another solution would be to simply increase the size of A[10] to A[25].</p><p class="P10"> </p><p class="P4"><span class="T11">d. 1. We shouldn't write #include “a.h” in c.c since </span><span class="T12">it is included in b.h, which is already included in           </span></p><p class="P11">         c.c.</p><p class="P12">    2. <span class="T17">This command wouldn't cause multiple definition of the function func_a because the interface a.h    </span></p><p class="P16">        defines the function a.h only if it was not defined before using the command #ifndef A_H.</p><p class="P16">        The first time func_a is defined, it also defines the literal A_H, thus not allowing for multiple      </p><p class="P16">        definition.</p><p class="P5"><span class="T12">    </span><span class="T13">3.  </span><span class="T19">The command isn't working properly because there are missing links in the command, and a.c </span></p><p class="P17">         can't find some needed information and definitions.</p><p class="P5"><span class="T13">         </span><span class="T14">We can fix the command by typing gcc a.c </span><span class="T15">-c</span><span class="T14"> -Wall. This will allow us to compile the file a.c                             </span></p><p class="P13">         without performing the linkage process, outputing the file a.o.</p><p class="P6"><span class="T14">    4. </span><span class="T16">The command fails </span><span class="T20">because there are missing files for the linking process, which the file c.c needs</span></p><p class="P18">        in order to work.</p><p class="P18">        A solution to this problem would be to write the command gcc a.c b.c c.c -Wall -o bella.</p></body></html>